---
title: callbacks.mixup
keywords: 
sidebar: home_sidebar
tags: 
summary: "Implements [mixup](https://arxiv.org/abs/1710.09412) training method"
---

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="callbacks.mixup">callbacks.mixup<a class="anchor-link" href="#callbacks.mixup">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">autoreload</span> 2
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">fastai.docs</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">get_mnist</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-is-Mixup?">What is Mixup?<a class="anchor-link" href="#What-is-Mixup?">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This module contains the implementation of a data augmentation technique called <a href="https://arxiv.org/abs/1710.09412">Mixup</a>. It is extremely efficient at regularizing models in computer vision (we used it to get our time to train CIFAR10 to 94% on one GPU to 6 minutes).</p>
<p>As the name kind of suggests, the authors of the mixup article propose to train the model on a mix of the pictures of the training set. Let’s say we’re on CIFAR10 for instance, then instead of feeding the model the raw images, we take two (which could be in the same class or not) and do a linear combination of them: in terms of tensor it’s</p>
<p><code>new_image = t * image1 + (1-t) * image2</code></p>
<p>where t is a float between 0 and 1. Then the target we assign to that image is the same combination of the original targets:</p>
<p><code>new_target = t * target1 + (1-t) * target2</code></p>
<p>assuming your targets are one-hot encoded (which isn’t the case in pytorch usually). And that’s as simple as this.</p>
<p><img src="imgs/mixup.png" alt="mixup"></p>
<p>Dog or cat? The right answer here is 70% dog and 30% cat!</p>
<p>As the picture above shows, it’s a bit hard for a human eye to comprehend the pictures obtained (although we do see the shapes of a dog and a cat) but somehow, it makes a lot of sense to the model which trains more efficiently. The final loss (training or validation) will be higher than when training without mixup even if the accuracy is far better, which means that a model trained like this will make predictions that are a bit less confident.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Basic-Training">Basic Training<a class="anchor-link" href="#Basic-Training">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To test this method, we will first build a <a href="/layers.html#simple_cnn"><code>simple_cnn</code></a> and train it like we did with <a href="/basic_train.html"><code>basic_train</code></a> so we can compare its results with a network trained with Mixup.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">simple_cnn</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span> <span class="o">=</span> <span class="n">Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




 
 
<div id="90c46676-52b2-4f6b-989a-d0b827ebc052"></div>
<div class="output_subarea output_widget_view ">
<script type="text/javascript">
var element = $('#90c46676-52b2-4f6b-989a-d0b827ebc052');
</script>
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "", "version_major": 2, "version_minor": 0}
</script>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Total time: 01:48
epoch  train loss  valid loss
0      0.145979    0.120332    (00:05)
1      0.108739    0.087095    (00:05)
2      0.070191    0.067030    (00:05)
3      0.052661    0.050815    (00:05)
4      0.043482    0.052751    (00:05)
5      0.030989    0.028319    (00:05)
6      0.032012    0.032017    (00:05)
7      0.028828    0.020024    (00:05)
8      0.027663    0.019214    (00:05)
9      0.021449    0.018527    (00:05)
10     0.019079    0.020859    (00:05)
11     0.013967    0.018244    (00:05)
12     0.013730    0.019252    (00:05)
13     0.016689    0.016771    (00:05)
14     0.012292    0.024717    (00:05)
15     0.014456    0.013594    (00:05)
16     0.011270    0.040473    (00:05)
17     0.011406    0.020919    (00:05)
18     0.010532    0.020605    (00:05)
19     0.012827    0.014805    (00:05)

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mixup-implementation-in-the-library">Mixup implementation in the library<a class="anchor-link" href="#Mixup-implementation-in-the-library">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the original article, the authors suggested four things:</p>

<pre><code>1. Create two separate dataloaders and draw a batch from each at every iteration to mix them up
2. Draw a t value following a beta distribution with a parameter alpha (0.4 is suggested in their article)
3. Mix up the two batches with the same value t.
4. Use one-hot encoded targets

</code></pre>
<p>The implementation of this module is based on these suggestions but was modified when experiments suggested modifications with positive impact in performance.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The authors suggest to use the beta distribution with the same parameters alpha. Why do they suggest this? Well it looks like this:</p>
<p><img src="imgs/betadist-mixup.png" alt="betadist"></p>
<p>so it means there is a very high probability of picking values close to 0 or 1 (in which case the image is almost from 1 category) and then a somewhat constant probability of picking something in the middle (0.33 as likely as 0.5 for instance).</p>
<p>While this works very well, it’s not the fastest way we can do this and this is the first suggestion we will adjust. The main point that slows down this process is wanting two different batches at every iteration (which means loading twice the amount of images and applying to them the other data augmentation function). To avoid this slow down, ou be a little smarter and mixup a batch with a shuffled version of itself (this way the images mixed up are still different).</p>
<p>Using the same parameter t for the whole batch is another suggestion we will modify. In our experiments, we noticed that the model can train faster if we draw a different <code>t</code> for every image in the batch (both options get to the same result in terms of accuracy, it’s just that one arrives there more slowly).
The last trick we have to apply with this is that there can be some duplicates with this strategy: let’s say we decide to mix <code>image0</code> with <code>image1</code> then <code>image1</code> with <code>image0</code>, and that we draw <code>t=0.1</code> for the first, and <code>t=0.9</code> for the second. Then</p>
<p><code>image0 * 0.1 + shuffle0 * (1-0.1) = image0 * 0.1 + image1 * 0.9</code>
<code>image1 * 0.9 + shuffle1 * (1-0.9) = image1 * 0.9 + image0 * 0.1</code></p>
<p>will be the sames. Of course we have to be a bit unlucky but in practice, we saw there was a drop in accuracy by using this without removing those duplicates. To avoid them, the tricks is to replace the vector of parameters <code>t</code> we drew by:</p>
<p><code>t = max(t, 1-t)</code></p>
<p>The beta distribution with the two parameters equal is symmetric in any case, and this way we insure that the biggest coefficient is always near the first image (the non-shuffled batch).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Adding-Mixup-to-the-Mix">Adding Mixup to the Mix<a class="anchor-link" href="#Adding-Mixup-to-the-Mix">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we will add <a href="/callbacks.mixup.html#MixUpCallback"><code>MixUpCallback</code></a> to our Learner so that it modifies our input and target accordingly.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cb</span> <span class="o">=</span> <span class="n">MixUpCallback</span><span class="p">(</span><span class="n">learn</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">simple_cnn</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Before we train, we have to modify the loss so that it is compatible with Mixup.</p>
<p>Pytorch was very careful to avoid one-hot encoding targets when it could, so it seems a bit of a drag to undo this. Fortunately for us, if the loss is a classic <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.functional.cross_entropy">cross-entropy</a>, we have</p>
<p><code>loss(output, new_target) = t * loss(output, target1) + (1-t) * loss(output, target2)</code></p>
<p>so we won’t one-hot encode anything and just compute those two losses then do the linear combination.</p>
<p>The class for using the new, mixup-adapted loss, is included in the <a href="/callbacks.mixup.html"><code>callbacks.mixup</code></a> module and we just need to call it when running fit.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span> <span class="o">=</span> <span class="n">Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">loss_fn</span><span class="o">=</span><span class="n">MixUpLoss</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Training the net with Mixup improves our validation loss by x%!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




 
 
<div id="13b3c2ae-c845-41a3-abc2-a51ee86a0fdd"></div>
<div class="output_subarea output_widget_view ">
<script type="text/javascript">
var element = $('#13b3c2ae-c845-41a3-abc2-a51ee86a0fdd');
</script>
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "", "version_major": 2, "version_minor": 0}
</script>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Total time: 01:27
epoch  train loss  valid loss
0      0.367593    0.164917    (00:05)
1      0.346800    0.136051    (00:05)
2      0.334471    0.111633    (00:05)
3      0.324001    0.113102    (00:05)
4      0.319147    0.093772    (00:05)
5      0.311415    0.092217    (00:05)
6      0.311161    0.087219    (00:05)
7      0.304196    0.085166    (00:05)
8      0.298274    0.073888    (00:05)
9      0.304680    0.095128    (00:05)
10     0.299359    0.082207    (00:05)
11     0.303683    0.079501    (00:05)
12     0.302099    0.070518    (00:05)
13     0.303605    0.069616    (00:05)
14     0.295498    0.089329    (00:05)

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Use-by-calling-.mixup()-on-Learner">Use by calling .mixup() on Learner<a class="anchor-link" href="#Use-by-calling-.mixup()-on-Learner">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <a href="/callbacks.mixup.html"><code>MixUpCallback</code></a> module is integrated into the <a href="/basic_train.html#Learner"><code>Learner</code></a> so it can be applied by just calling .mixup() on the <a href="/basic_train.html#Learner"><code>Learner</code></a> object.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span> <span class="o">=</span> <span class="n">Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span><span class="o">.</span><span class="n">mixup</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




 
 
<div id="3eebf311-2730-4b8b-b0a0-ca66989fed77"></div>
<div class="output_subarea output_widget_view ">
<script type="text/javascript">
var element = $('#3eebf311-2730-4b8b-b0a0-ca66989fed77');
</script>
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "82e3e19fe9c04370b8900928c36482e6", "version_major": 2, "version_minor": 0}
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Methods">Methods<a class="anchor-link" href="#Methods">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4><a id=on_batch_begin></a><code>on_batch_begin</code></h4>
<p><code>on_batch_begin</code>(<code>last_input</code>, <code>last_target</code>, <code>kwargs</code>)</p>
<p>Set HP before the step is done. Returns xb, yb (which can allow us to modify the input at that step if needed) <a href="https://github.com/fastai/fastai_pytorch/blob/master/fastai/callbacks/mixup.py#L14">[source]</a></p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2><a id=MixUpLoss></a>class <code>MixUpLoss</code></h2>
<p><code>MixUpLoss</code>(<code>crit</code>) :: <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module"><code>Module</code></a></p>
<p>Adapts the loss function to go with mixup. <a href="https://github.com/fastai/fastai_pytorch/blob/master/fastai/callbacks/mixup.py#L30">[source]</a></p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4><a id=forward></a><code>forward</code></h4>
<p><code>forward</code>(<code>output</code>, <code>target</code>)</p>
<p>Should be overridden by all subclasses.</p>
<p>.. note::
    Although the recipe for forward pass needs to be defined within
    this function, one should call the :class:<code>Module</code> instance afterwards
    instead of this since the former takes care of running the
    registered hooks while the latter silently ignores them. <a href="https://github.com/fastai/fastai_pytorch/blob/master/fastai/callbacks/mixup.py#L37">[source]</a></p>

</div>

</div>

</div>
</div>

</div>
</div>
 

